\documentclass[multip]{SGGW-thesis}
\title{Implementacja sieciowej gry wideo z wykorzystaniem silnika Unreal Engine 4}
\author{Maciej Wygoda}
\date{2017}
\university{Szkoła Główna Gospodarstwa Wiejskiego\\w Warszawie}
\dep{Wydział Zastosowań Informatyki i Matematyki}
\Etitle{Implementation of an online video game using Unreal Engine 4}
\album{172407}
\thesis{Praca dyplomowa inżynierska}
\course{Informatyka}
\promotor{dr. Bartłomieja Kubicy}
\pworkplace{Wydział Zastosowań Informatyki i Matematyki\\Katedra Zastosowań Informatyki}

%obrazki
\usepackage{graphicx}
\usepackage{enumitem}
%\usepackage{hyperref}
%https://tex.stackexchange.com/a/3034
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
%https://tex.stackexchange.com/questions/28333/continuous-v-per-chapter-section-numbering-of-figures-tables-and-other-docume
\usepackage{chngcntr}
\counterwithout{figure}{chapter}

\begin{document}
\maketitle
\twoppage{Maciej Wygoda}{172407}{ktore rodzialy + strony}{Marcin Szadkowski}{wpisz swoj numer albumu}{ktore rodzialy + strony}
\statementpage
\abstractpage
{Implementacja sieciowej gry wideo z wykorzystaniem silnika Unreal Engine 4}
{Niniejsza praca jest opisem implementacji sieciowej gry wideo pod tytułem ,,thesis\_1`` z wykorzystaniem silnika Unreal Engine 4. Zawiera opis silnika, prezentuje architekturę gry oraz zastosowane rozwiązania.}
{Unreal Engine 4, tworzenie gier wideo, gamedev, gra wideo}
{Implementation of an online video game using Unreal Engine 4}
{This study is a description of an implementation of an online video game ,,thesis\_1`` using Unreal Engine 4. It describes the engine and presents the game's architecture and applied solutions.}
{Unreal Engine 4, game development, gamedev, video game}

\tableofcontents

\chapter{Wstęp}
Gry wideo stanowią rozrywkę dla coraz szerszego grona odbiorców, a sama branża nieustannie rośnie, o czym najlepiej świadczy fakt, iż pod względem wygenerowanych przychodów prześcignęła już branże filmową oraz muzyczną~\cite{nasdaq-video-games-industry}. Gry coraz częściej postrzegane są jako nowoczesne medium przekazu oraz forma wyrazu artystycznego i poruszają tematy dotychczas zarezerwowane dla literatury i kinematografii. 
\newline Tworzenie gier wideo ({\em ang. game development}) to obszerne zagadnienie łączące w sobie wiele dziedzin. Od strony technicznej są to między innymi grafika komputerowa, inżynieria oprogramowania, programowanie komputerów, bezpieczeństwo komputerowe, matematyka. W związku z tym, że stworzenie gry to proces długi i skomplikowany, istnieje wiele narzędzi wspierających go, a jednym z najpopularniejszych jest silnik {\em Unreal Engine 4} (zwany dalej "UE4").
\section{Cel i zakres pracy}
Głównym celem niniejszej pracy jest rozwój wiedzy o procesie tworzenia gier wideo. Ponadto motywację stanowiły chęć zgłębienia technologii UE4, podjęcia technicznego wyzwania, jakie stawia zaprogramowanie gry wideo oraz pasja do gier. Na całą pracę składa się zaprojektowanie i zaimplementowanie gry z użyciem UE4 oraz podstawowy opis silnika i implementacji gry. 
\newline Uwagę skupiono między innymi na poznawaniu działania i efektywnym wykorzystywaniu technologii UE4 oraz oprogramowania do modelowania i animacji Blender oraz zdobyciu doświadczenia w pracy zespołowej.
% oraz opracowaniu metodyki pracy, która pozwoli na wielokrotne wykorzystanie napisanego kodu oraz skrócenie czasu tworzenia oprogramowania.
\newline Praca ta może z powodzeniem służyć za przykład i drogowskaz dla osób chcących napisać własną grę.

\chapter{Unreal Engine 4}
\section{Czym jest silnik gry?}
Przez pojęcie ,,silnik gry`` rozumie się zbiór funkcji i narzędzi ({\em ang. framework}) wspierający tworzenie gier. Musi on oferować przede wszystkim renderowanie grafiki, dźwięku i obsługę sterowania aczkolwiek obecnie najpopularniejsze silniki posiadają znacznie więcej funkcji, a są to między innymi obsługa sieci, symulacja fizyki, edytory shaderów i efektów cząsteczkowych, produkcja przerywników filmowych oraz obsługa wielu platform na przykład komputerów, konsol czy urządzeń mobilnych takich jak smartfony. Każdy popularny silnik dystrybuowany jest wraz z edytorem będacym graficznym interfejsem między programistą, a funkcjami silnika.
\newline Wykorzystanie jednego silnika do stworzenia wielu różnych gier znacząco skraca okres produkcji i stanowi powszechną w branży praktykę.\cite{learning-unreal}\cite{wiki-game-engine}

\section{Funkcje silnika Unreal Engine 4}
%tu chodzi o ficzery unreala, info m.in. z naszej prezentacji na seminarium oraz
%\newline\url{https://www.unrealengine.com/en-US/features}
%\newline\url{https://docs.unrealengine.com/latest/INT/Engine/index.html}
UE4 swoją popularność zawdzięcza między innymi otwartemu źródłu, co w pewnym stopniu umożliwia producentom gier dostosowanie silnika do własnych potrzeb na przykład poprzez programowanie narzędzi dla mniej technicznych członków zespołu czy modyfikacje w działaniu silnika. Ponadto UE4 jest w stanie renderować grafikę bardzo zbliżoną do fotorealizmu, co w połączeniu z szeroką gamą oferowanych funkcji sprawia, że poza grami korzysta się z niego na przykład do produkcji spotów i aplikacji reklamowych. \cite{the-human-race}\cite{ikea-vr}
\newline
\newline Oprócz podstawowych funkcji takich jak renderowanie grafiki czy obsługa sterowania do dyspozycji oddane zostały między innymi \cite{docs-ue4-features}:
\begin{description}
\item[Symulacja fizyki:]UE4 korzysta z silnika fizyki {\em PhysX 3.3} dzięki czemu wiarygodnie symuluje kolizje obiektów i inne oddziaływania fizyczne. Producenci mają również możliwość modyfikowania panujących zasad celem lepszego przedstawienia własnej wizji.
\item[Edytor interfejsu użytkownika:] Interfejs stanowi istotny element w komunikacji między grą, a grającym. UE4 zapewnia rozbudowany edytor pozwalający na tworzenie między innymi takich elementów interfejsu jak {\em HUD (head-up display)} czy menu.
\item[Drzewa behawioralne:]Stanowią one podstawę sztucznej inteligencji w UE4 i pozwalają na zaprogramowanie zachowania postaci sterowanych przez komputer w zależności od odbieranych przez nie bodźców i stanu sceny.
\clearpage \item[Sequencer:]Jest to narzędzie służące do produkcji przerywników filmowych. Jego obsługa przypomina pracę z oprogramowaniem do montażu filmów i modelowania 3D. Edytor ten uwzględnia elementy takie jak oś czasu, ujęcia kamery, szkielety i animacje obiektów.
\item[Networking:]UE4 powstał z myślą o rozgrywce sieciowej, wobec tego dużo uwagi poświęcono stworzeniu odpowiedniej abstrakcji ułatwiającej programowanie komunikacji sieciowej. Komunikacja ta wykorzystuje model klient-serwer co oznacza, że istnieje jeden serwer z autorytatywną instancją świata oraz wielu klientów, których światy są aktualizowane na podstawie tego, co dzieje się na serwerze. Aktualizacje te opierają się o aktualizacje właściwości obiektów i zdalne wywołania procedur {\em (ang. remote procedure calls - RPC)}. W obu przypadkach wykorzystywany jest protokół {\em UDP}, który jest zawodny, ale generuje o wiele mniejszy narzut na sieć niż w przypadku {\em TCP}. UE4 ma zaimplementowany własny system zapewniający częściową niezawodność komunikacji. \cite{unreal-wiki-replication}
%https://docs.unrealengine.com/latest/INT/Gameplay/Networking/index.html
\item[Analiza wydajności:]Osiągnięcie iluzji ruchomego obrazu wymaga wygenerowania przynajmniej 15 klatek na sekundę ({\em ang. frames per second - FPS}), obecnie na konsolach do gier pożądaną wartością jest przynajmniej 30FPS, na komputerach 60FPS, a w tytułach esportowych nawet dwa razy więcej. Miara ta jest odzwierciedleniem płynności obrazu i wydajności gry, a na wydajność składają się stopień skomplikowania scen i obliczeń oraz optymalizacja. UE4 zapewnia narzędzia do profilowania, dzięki którym łatwiejsze staje się zidentyfikowanie obszarów wymagających optymalizacji.
\item[Edytor materiałów:]W konwencji UE4 materiał to zbiór informacji o wizualnej stronie obiektu. Do pewnego stopnia można o nim myśleć jak o farbie. Należy jednak uwzględnić, że materiał poza kolorem czy teksturą definiuje również rodzaj powierzchni obiektu (na przykład metal, drewno), przezroczystość i inne cechy, które mogą mieć wpływ na zachowanie światła padającego na dany obiekt. UE4 posiada rozbudowany edytor materiałów opierający się na programowaniu graficznym ({\em ang. visual scripting}).
\item[Blueprints Visual Scripting:]Jest to system graficznego programowania rozgrywki oparty o węzły reprezentujące elementy takie jak funkcje, klasy czy zmienne, które po połączeniu stanowią pewną logikę (rys. \ref{fig-bp-example}). Za pomocą blueprintów można (często w krótszym czasie) osiągnąć podobny efekt co za pomocą kodu przy czym dla osób mniej technicznych są one o wiele prostsze w użyciu. Ponadto mogą dziedziczyć klasy napisane kodem, a programiści mają możliwość rozwijania blueprintów poprzez programowanie kolejnych węzłów do użycia przez resztę zespołu. Jest możliwe napisanie kompletnej gry bez nawet jednej linii kodu, a jedynie z użyciem blueprintów. Nie oznacza to jednak, że kod stał się bezużyteczny. W każdym wypadku kod {\em C++} jest wydajniejszy od blueprintów (to znaczy szybciej się wykonuje, co bezpośrednio wpływa na liczbę generowanych klatek na sekundę), w wielu przypadkach jest czytelniejszy (na przykład obliczenia w pętli) i łatwiejszy w utrzymaniu (na przykład kontrola wersji przy pracy zespołowej).\cite{docs-blueprints}
\newline Oba te podejścia są wykorzystywane w profesjonalnym środowisku, a kluczem do sukcesu jest ich umiejętne połączenie, co zaprezentowano w dalszej części tej pracy.
\begin{figure}
	\centering
		\includegraphics[width=1\textwidth]{figures/bp_example.jpg}
	\caption{Przykład blueprinta}
	\label{fig-bp-example}
\end{figure}

\end{description}

\section{Konwencja i architektura rozgrywki}
\label{sec:konwencja}
%\url{https://docs.unrealengine.com/latest/INT/Gameplay/Framework/index.html}
%\newline\url{https://docs.unrealengine.com/latest/INT/Gameplay/Framework/QuickReference/index.html}
%\newline obowiazkowo obrazek z dolu strony :D
Styl rozgrywki zależy od gry i wizji jej autora, jednak istnieją pewne cechy wspólne widoczne w niemal każdym tytule. Jest to na przykład sterowanie za pomocą urządzeń wejścia czy pewien zbiór zasad gry. Z tego powodu w UE4 przyjęto zaprezentowaną poniżej konwencję dotyczącą rozgrywki (rys. \ref{fig-gameplay-chart}).\cite{docs-gameplay-framework}
\begin{description}
\item[Actor:]Jest to bazowa klasa dla każego obiektu, który można umieścić w scenie. Obiekty te nie muszą mieć fizycznej reprezentacji. Często zawierają dodatkowe komponenty ~({\em ActorComponents}) określające między innymi w jaki sposób obiekt się porusza czy jak jest renderowany. Oprócz tego {\em aktor} posiada obsługę replikacji właściwości i wywołań funkcji przez sieć.
\item[Pawn:]Jest to {\em aktor}, który może być kontrolowany przez gracza lub komputer. Stanowi ich fizyczną reprezentację w grach, które tego wymagają.
\item[Character:]Jest to humanoidalny {\em pawn} rozszerzony o następujące komponenty:
	\begin{description}
	\item[SkeletalMeshComponent] wykorzystywany przy animacjach szkieletowych,
	\item[CapsuleComponent] wykorzystywany przy kolizjach z innymi obiektami,
	\item[CharacterMovementComponent] opisujący ludzkie ruchy takie jak chodzenie, bieganie czy pływanie oraz właściwości związane z ruchem na przykład prędkość chodzenia czy wpływ grawitacji.
	\end{description}
\item[Controller:] jest to {\em aktor}, który po przejęciu {\em pawna} sprawuje nad nim kontrolę. Wyróżniamy dwa rodzaje: {\em PlayerController}, który stanowi interfejs między grającym, a sterowaną przez niego postacią (reprezentuje wolę gracza) oraz {\em AIController}, który decyduje o zachowaniach postaci na podstawie zaprogramowanych wcześniej drzew behawioralnych.
\newline {\em PlayerController} danego gracza w przypadku rozgrywki sieciowej występuje w dwóch instancjach: po jednej na serwerze oraz urządzeniu grającego, co należy brać pod uwagę podczas programowania tego elementu.
\item[HUD ({\em ang. head-up display}):] podręczne informacje dla gracza na przykład jego obecny wynik, stan zdrowia sterowanej przez niego postaci czy tak zwana minimapa.
\item[Camera:] decyduje o perspektywie, z której grający obserwuje scenę.\newline Jest elementem PlayerControllera.
\item[GameMode:] zawiera informacje takie jak zasady gry czy warunki zwycięstwa. Nie powinien zawierać żadnych informacji potrzebnych klientom, ponieważ istnieje jedynie na serwerze. Decyduje również o tym, który {\em GameState} i {\em PlayerState} zostanie wykorzystany. Wybór {\em GameMode-a} zależy od wczytywanego poziomu.
\item[GameState:] zawiera informacje o obecnym stanie rozgrywki na przykład czy mecz już się rozpoczął, wykonane misje, wyniki, listę graczy. {\em GameState} istnieje zarówno na serwerze jak i u klientów oraz jest replikowalny.
\item[PlayerState:] zawiera informacje o uczestniku rozgrywki na przykład jego imię, wynik czy zespół, do którego należy. Zarówno serwer jak i wszyscy klienci posiadają kopie {\em PlayerState-ów} dotyczących każdego grającego (co nie ma miejsca w przypadku {\em PlayerControllerów} -- każdy klient wie jedynie o swoim {\em PlayerControllerze}).
\item[GameInstance:] zawiera informacje o danej instancji gry. Istnieje jeden obiekt tej klasy na każdą uruchomioną grę i pozostaje on do dyspozycji aż do jej wyłączenia. Wczytywanie poziomów nie ma wpływu na {\em GameInstance}, dzięki czemu klasa ta umożliwia przenoszenie informacji między poziomami.
\end{description}
%dopisac cos ze trzymalismy sie tej konwencji i dalej prezentujemy jej wykorzystanie
Stosowanie się do tej konwencji zaprezentowano w rozdziale \ref{implementacja} skupiającym się na implementacji gry ,,thesis\_1``.

\begin{figure}
	\centering
		\includegraphics[width=1\textwidth]{figures/gameplay_chart.jpg}
	\caption{Diagram architektury rozgrywki}
	\label{fig-gameplay-chart}
\end{figure}

\chapter{Przykładowy przebieg rozgrywki} %zeby opisac JAK zaimplementowalismy, trzeba najpierw opisac CO zaimplementowalismy
\begin{enumerate}
	\item Gracz 1 uruchamia grę po raz pierwszy, wobec czego jest przenoszony do menu opcji w celu wybrania ustawień. Wpisuje swoje imię w odpowiednim polu, wybiera klasę postaci, zdolności, obrazek oraz czy będzie korzystał z klawiatury i myszki czy z kontrolera do gier (pada). Klika przycisk {\em Accept}, w katalogu gry powstaje plik z zapisem ustawień, gracz przenoszony jest do menu głównego.
	\item Gracz 2 uruchamiał już grę wcześniej, wobec czego posiada plik z zapisem. Po uruchomieniu przenoszony jest prosto do menu głównego.
	\item Gracz 1 w menu głównym klika przycisk {\em Host game}, a następnie ustala nazwę serwera, maksymalną liczbę graczy i metodę połączenia (Internet lub LAN). Aplikacja tego gracza będzie jednocześnie serwerem i klientem. Gracz zatwierdza przyciskiem {\em Accept}, po czym wczytuje mu się poziom, otrzymuje kontrolę nad swoją postacią, a serwer jest gotowy do przyjmowania klientów.
	\item Aplikacja Gracza 2 będzie klientem. W menu głównym gracz klika przycisk {\em Find game}, a następnie podaje adres IP Gracza 1 i zatwierdza przyciskiem {\em Connect}. Po chwili łączy się z serwerem i otrzymuje kontrolę nad swoją postacią.
	\item Obaj gracze prowadzą rozgrywkę, mogą chodzić, skakać, unikać oraz używać wybranych wcześniej zdolności. Sterowanie zależy od ustawień (mysz i klawiatura lub pad). Atakowanie postaci przeciwnika odbiera jej punkty zdrowia. Po utraceniu wszystkich punktów zdrowia dany gracz zostaje wyłączony z rozgrywki na siedem sekund, a wynik jego rywala jest zwiększany o jeden punkt. Obaj gracze widzą na swoich ekranach tablicę wyników aktualizowaną na bieżąco. Po upływie 7 sekund czasu gracz z powrotem otrzymuje kontrolę nad swoją postacią i gra jest kontynuowana.
	\item Gracze kończą rozgrywkę przyciskiem {\em X} w prawym górnym rogu okna. Gracz o najwyższym wyniku zostaje zwycięzcą.
\end{enumerate}

\chapter{Opis implementacji gry ,,thesis\_1``}
\label{implementacja}

\section{Uruchomienie gry i podstawowe funkcje}
Wywołanie pliku wykonywalnego z grą ({\em thesis\_1.exe}) powoduje uruchomienie silnika, utworzenie obiektu klasy {\em GameInfoInstance} (opisanej w podrozdziale \ref{gameinfoinstance}), a następnie wczytanie początkowego poziomu {\em MainMenu}, który wywołuje funkcję {\em SaveGameCheck} z {\em GameInfoInstance} sprawdzającą czy istnieje plik z zapisem gry (system opisany w podrozdziale \ref{sejwy}) i wyświetlający interfejs użytkownika. Na tym etapie grający otrzymuję kontrolę nad dalszym przebiegiem programu. Sprowadza się ona do wywołań funkcji z {\em GameInfoInstance} poprzez interfejs.
	\subsection{GameInfoInstance}
		\label{gameinfoinstance}
		Klasa {\em GameInfoInstance} dziedziczy po klasie {\em GameInstance} (opisanej w podrozdziale \ref{sec:konwencja}), zawiera podstawowe informacje wykorzystywane w innych obszarach gry (na przykład dostępne zdolności i klasy postaci wykorzystywane w systemie opisanym w podrozdziale \ref{wybor-postaci}) oraz odpowiada za wyświetlanie {\em widgetów} interfejsu (podrozdział \ref{interface}) i tworzenie oraz dołączanie do istniejących rozgrywek sieciowych (podrozdział \ref{networking}).
	

\section{Interfejs}
	\label{interface}
	Podstawę interfejsu w UE4 stanowią {\em widgety} czyli elementy posiadające pewną logikę, które można wyświetlać w oknie użytkownika w warstwie interfejsu. Są to na przykład przyciski, listy, suwaki, pola tekstowe i tym podobne. Za pomocą edytora {\em widgetów} z podstawowych {\em widgetów} buduje się bardziej skomplikowane (na przykład menu główne lub tablica wyników), z których konstruuje się docelowy interfejs.
	\newline
	\newline W przypadku gry ,,thesis\_1`` {\em widgety} wyświetlane są poprzez wywoływanie odpowiednich funkcji z {\em GameInfoInstance} (rys. \ref{fig-save-game-check}, \ref{fig-show-host-menu}). 
	\newline Z menu głównego grający ma możliwość przejścia do menu tworzenia lub dołączania do gry (rozdział \ref{networking}), menu opcji (rozdział \ref{wybor-postaci}) oraz zamknięcia gry.

	\begin{figure}
		\centering
			\includegraphics[width=1\textwidth]{figures/savegamecheck.jpg}
		\caption{Funkcja wywołująca wyświetlenie {\em widgetu} interfejsu wybranego na podstawie istnienia pliku zapisu stanu}
		\label{fig-save-game-check}
	\end{figure}
	
	\begin{figure}
		\centering
			\includegraphics[width=1\textwidth]{figures/showhostmenu.jpg}
		\caption{Funkcja wyświetlająca {\em widget} interfejsu hostowania gry}
		\label{fig-show-host-menu}
	\end{figure}

\clearpage
\section{System zapisu stanu gry}
	\label{sejwy}
	W grze ,,thesis\_1`` zaimplementowano system zapisu gry, który umożliwia grającemu zachowanie swoich ustawień do kolejnego uruchomienia lub przeniesienia ich na inny komputer. System ten korzysta z klasy {\em PlayerSaveGame}, funkcji {\em SaveGameToSlot} i {\em LoadGameFromSlot} oraz struktury {\em PlayerInfo}. Obiekty klasy {\em PlayerSaveGame} są serializowane i deserializowane z pliku "thesis\_1/Saved/SaveGames/PlayerSettingsSave.sav" oraz posiadają w sobie strukturę {\em PlayerInfo}, w której przechowywane są ustawienia grającego: imię, obrazek, klasa postaci, rodzaj sterowania oraz zdolności.
	\newline Po uruchomieniu gry wywoływana jest funkcja {\em SaveGameCheck} z klasy {\em GameInfoInstance}, która jest odpowiedzialna za sprawdzenie, czy istnieje plik \newline "thesis\_1/Saved/SaveGames/PlayerSettingsSave.sav". Jeżeli nie istnieje, grający przenoszony jest do menu opcji, w którym wybiera ustawienia i powoduje stworzenie pliku z zapisem. Jeżeli plik ten istnieje, grający przenoszony jest do menu głównego, a dane z pliku wczytywane są przy wejściu do menu opcji (w celu wyświetlenia zapisanych ustawień) lub dołączeniu do rozgrywki (w celu utworzenia postaci oraz zdolności zgodnych z wyborami grającego). 
\clearpage
\section{Postacie i zdolności}
	\label{characters-skills}
Gra składa się wielu nieodzownych elementów, jednym z istotniejszych jest niewątpliwie postać którą gracz kontroluje.
	\subsection{Pawn a PlayerController}
	Podczas tworzenia postaci pojawia się wiele pytań i problemów do rozwiązania.
Jednym z nich jest sposób zbierania danych od gracza w sposób pozwalający na ponowne wykorzystanie kodu w postaciach o podobnych cechach. UE4 pozwala na obsługę danych wejściowych w klasach Pawn lub w PlayerController. Rzeczą wartą rozważenia jest sposób w jaki rozdzielimy obsługę wejścia pomiędzy tymi klasami\cite{docs-playercontroller}. W prostych przypadkach możliwa jest obsługa zebranych informacji o woli gracza całkowicie w klasie Pawn. Jednak gdy obsługa sterowania jest skomplikowana implementacja PlayerController’a staje się nieunikniona. PlayerController pozwala na przykład na sterowanie wieloma awatarami na jednej maszynie czy dynamiczne przełączanie się pomiędzy postaciami.  Kolejną zaletą PlayerController’a jest to, że jedna jego instancja jest przypisana do gracza przez całą rozgrywkę a kontrolowane przez niego obiekty klasy Pawn mogą się zmieniać. Przykładowo podczas odradzania naszej postaci utworzony zostaje nowy obiekt klasy Pawn a kontroler pozostaje ten sam, więc dane których nie chcemy stracić takie jak zdobyte punkty czy złoto powinny być składową PlayerController'a.
	W projekcie jako klasy bazowej do wirtualnej reprezentacji gracza użyto klasy Character, a dane wejściowe są całkowicie obsługiwane przez PlayerController
	\subsection{Dygresja na temat nazewnictwa klas}
	Utworzone klasy pochodne posiadają mylący przedrostek Base. Jest to spowodowane faktem, że klasy napisane w C++ są następnie wykorzystywane jako klasy bazowe blueprint'ów postaci. Wszystkie podstawowe umiejętności jak poruszanie, skakanie czy obracanie się postaci zostały zaimplementowane za pomocą języka C++, które później zostały odziedziczone w blueprint'ach. Zyskano przez to warstwę abstrakcji oddzielającą niezbędne linie kodu od dodatkowych zdolności postaci, oraz łatwość zmian indywidualnych cech postaci za pomocą edytora blueprint'ów.
	\subsection{BaseCharacter}
	Na potrzeby projektu, w celu rozwinięcia podstawowych możliwości klasy Character udostępnionej przez silnik stworzono pochodną klasę BaseCharacter. Głównym celem było pozwolenie graczom na dowolne dostosowanie zdolności awatara. Problem ten został rozwiązany za pomocą tablicy obiektów USkill które posiadają metody OnPress oraz OnRelease zawierające logikę, która wykonywana jest gdy gracz naciska lub zwalnia odpowiedni przycisk.		
	Dodane zostały również zmienne których silnik używa do odgrywania odpowiednich animacji takich jak animacja uniku czy animacja czarowania oraz funkcje które zmieniają wartości tych zmiennych na serwerze gdy gracz na maszynie klienckiej wciśnie odpowiednie przyciski.
	\subsection{BasePlayerController}
	Klasa BasePlayerController jest stworzonym na potrzeby projektu rozszerzeniem klasy PlayerController. Jest ona odpowiedzialna za obsługę danych wejściowych zebranych od gracza. 
Gracz ma do wyboru dwa sposoby kontrolowania swojej postaci. W zależności od ustawień w odpowiednim oknie interfejsu użytkownika gracz może korzystać z klawiatury oraz myszy lub z kontrolera gier. Przy wyborze klawiatury i myszy postać można poruszać za pomocą klawiszy W, A, S oraz D a postać obrócona jest zawsze w kierunku kursora myszy.  Przy wyborze kontrolera gier kierunek, w który postać spogląda oraz porusza się jest wyznaczany na podstawie wychyleń odpowiednio, prawego oraz lewego drążka kontrolera. W obu przypadkach wciśniecie klawisza odpowiadającego za skok lub unik wywołuje odpowiednie metody które odpowiedzialne są za ruch naszego awatara oraz odegranie animacji. Wciśnięcie klawiszy odpowiadających za wykonanie zdolności działa 2 etapowo. Podczas wciśnięcia klawisza odgrywana jest animacja oraz wykonywany jest kod metody OnPress z klasy USkill, który może wykonać całą logikę zdolności lub przygotować naszą postać do momentu gdy gracz zwolni przycisk. Następnie wykona się metoda OnRelease, która może pozostać pusta, dokończyć wykonanie zdolności lub przywrócić gracza do stanu sprzed kliknięcia przycisku.
	\subsection{BaseCharacterMovementComponent}
	CharacterMovementComponent jest składową klasy Character odpowiedzialnej za przemieszczanie się awatara która automatycznie obsługuje networking.  System predykcji, replikacji i korekcji w sieciowych grach korzystających z CharacterMovementComponent działa w następujący sposób \cite{docs-charactermovementcomponent}. Co klatkę wywoływana jest metoda TickComponent gdzie obliczane są zmiany przyspieszenia oraz rotacji postaci. Następnie  w zależności od tego czy Character jest kontrolowany lokalnie czy sieciowo wywoływana jest metoda PerformMovement lub ReplicateMoveToServer. Metoda ReplicateMoveToServer dodaje ruch do listy oczekujących ruchów, następnie wywołuje lokalnie metodę PerformMovement i replikuje ruch na serwer poprzez zdalne wywołanie metody ServerMove. ServerMove przesuwa postać na serwerze na odpowiednie miejsce a następnie oblicza dystans pomiędzy pozycją postaci na serwerze i na maszynie klienckiej. Jeżeli dystans jest większy niż dopuszczalny, serwer  zdalnie wywołuje procedurę ClientAdjustPosition na kliencie, która przesuwa postać w odpowiednie miejsce. Jeżeli dane korekcyjne dotrą do klienta a jego pozycja zostanie poprawiona metoda ClientAdjustPosition wykona ponownie wszystkie ruchy, które zostały dodane na listę ruchów oczekujących po ruchu który został poprawiony przez serwer.
	CharacterMovementComponent posiada system symulacji i wygładzania. Dane o aktorze takie jak jego pozycja, prędkość czy rotacja są replikowane na inne maszyny za pomocą standardowego mechanizmu replikacji. Oznacza to, że maszyny nie dostają potrzebnych im informacji co klatkę. Wymusza to potrzebę symulacji zmian w położeniu postaci pomiędzy kolejnymi pakietami danych. Symulacja polega na przesuwaniu obiektu klasy Character zgodnie z ostatnio otrzymanymi danymi na temat jego ruchu. Gdy symulacja odbiega od rzeczywistych zmian, które zaszły na innych maszynach, UE4 wygładza zmianę pozycji w celu uniknięcia nagłego widocznego skoku pozycji awatara.
	Z powodu tych systemów wszystkie zdolności postaci modyfikujące jej położenie powinny zostać zaimplementowane poprzez rozszerzenie klasy CharacterMovementComponent.
Na potrzeby projektu, aby dodać możliwość uniku, polegającego na gwałtownym odskoku postaci w danym kierunku stworzona została klasa BaseCharacterMovementComponent. Implementacja polegała na nadpisaniu niezbędnych metod klasy bazowej\cite{uewiki-charmovement}. TickComponent oprócz swojego pierwotnego zadania sprawdza czy gracz wciska przycisk odpowiedzialny za unik. Jeżeli tak, dodawane są symulowane dane wejściowe, które naśladują poruszanie się gracza w odpowiednim kierunku. W celu zapewnienia szybszego poruszania się postaci podczas uniku, nadpisano metody GetMaxSpeed oraz GetMaxAcceleration które w zależności od zmiennej wskazującej na to czy postać wykonuje unik zwracają różne wartości. Ponadto wymagane było stworzenie klas używanych do predykcji i zapisywania ruchu na listę oczekujących w taki sposób by ewentualna poprawa ruchu spowodowana opóźnieniami transmisji danych uwzględniła kliknięcie przez gracza przycisku uniku.
	\subsection{Skill}
	Jedną z głównych cech gry ,,thesis\_1`` jest możliwość wyboru czterech z wielu dostępnych zdolności do używania w trakcie rozgrywki. W tym celu powstała klasa {\em Skill} reprezentująca daną zdolność. Klasa ta powstała za pomocą kodu {\em C++} z myślą o rozszerzaniu jej blueprintami, co umożliwiają znaczniki {\em Blueprintable} oraz {\em BlueprintNativeEvent} użyte w nagłówku klasy. Każda klasa dziedzicząca po {\em Skill} reprezentuje jedną zdolność i nadpisuje bazowe funkcje {\em OnPress} oraz {\em OnRelease} logiką danej zdolności. Decyduje też o tym, które klasy postaci mogą używać danej zdolności.
	\subsection{Wybór postaci i zdolności}
		\label{wybor-postaci}
	Grający ma możliwość wyboru postaci oraz zdolności w menu opcji, które pobiera informacje o klasach postaci i zdolnościach z {\em GameInfoInstace}. Aby zapobiec sytuacji, w której wybrana została zdolność przeznaczona dla innej postaci niż obecnie wybrana, interfejs aktualizuje listę dostępnych zdolności przy każdej zmianie klasy postaci. Po zaakceptowaniu zmian tablica zdolności trafia do {\em PlayerInfo} oraz pliku z zapisem gry. Przy dołączeniu do rozgrywki informacje te trafiają do {\em PlayerControllera} za pomocą funkcji {\em LoadPlayerInfo}, a stamtąd do {\em Charactera} poprzez funkcję {\em ABaseCharacter::LoadSkills()} przy każdym jego odrodzeniu.

\section{Networking -- tworzenie oraz dołączanie do rozgrywki sieciowej}
	\label{networking}
\clearpage
\section{Modele i Animacje }
Wartym zaznaczenia jest fakt, że głównym celem tworzenia modeli i animacji było zapoznanie się z narzędziami oraz samym procesem tworzenia tej części gier komputerowych. Podczas pracy nad projektem skupiono uwagę na aspektach technicznych. Znaczną część elementów środowiska udało się stworzyć za pomocą obracania i skalowania gotowych kształtów udostępnionych przez UE4, jednak bardziej skomplikowane kształty wymagały wymodelowania w osobnym oprogramowaniu dedykowanym do tego celu. Do stworzenia modeli i animacji użytych w projekcie wykorzystano oprogramowanie Blender w wersji 2.79 (rys. \ref{blender-start}).
\begin{figure}
		\centering
			\includegraphics[width=1\textwidth]{figures/blenderstart.jpg}
		\caption{Graficzny interfejs użytkownika programu Blender}
		\label{blender-start}
\end{figure}

	\subsection{Modelowanie}
Modelowanie w Blenderze polega na przemieszczaniu odpowiednich wierzchołków podstawowych kształtów, takich jak sfera czy sześcian, aż do momentu otrzymania upragnionego obiektu. 
\begin{figure}
		\centering
			\includegraphics[width=1\textwidth]{figures/adimodel.jpg}
		\caption{Model postaci wykorzystany w grze}
		\label{blender-model}
\end{figure}
Tak wymodelowaną siatkę obiektu (rys. \ref{blender-model}) możemy traktować jak kamienną rzeźbę. Na tym etapie animowanie jej jest praktycznie niemożliwe.
	\subsection{Rigging}
Następnym krokiem jest proces nazwany rigging\cite{whats-rigging}. Rigging polega na wyposażeniu modelu w kości, stawy oraz stworzeniu mapy wag informującej o tym jak dane kości mają wpływać na kształt modelu (rys. \ref{blender-rigging}).
\begin{figure}
		\centering
			\includegraphics[width=1\textwidth]{figures/adirig.jpg}
		\caption{Kości oraz stawy użyte w modelu (po lewej) oraz mapa wag dla jednej z kości (po prawej)}
		\label{blender-rigging}
\end{figure}
\clearpage
	\subsection{Animacje}
\begin{figure}
		\centering
			\includegraphics[width=1\textwidth]{figures/adiwalk.jpg}
		\caption{Jedna z klatek animacji chodzenia}
		\label{blender-anim}
\end{figure}
Z odpowiednio przygotowanym modelem możemy zacząć animowanie postaci. Proces tworzenia animacji polega na ustawianiu kości w odpowiednich pozach i zapisywaniu ich zmian w rotacji oraz położeniu (rys. \ref{blender-anim}). 
	Nawet w animacjach podstawowych ruchów pojawia się wiele ciekawych problemów do rozwiązania. Przykładem może być animacja skoku, w której problematyczny jest zmienny czas przebywania postaci w powietrzu. Animacja zeskakiwania z wysokiej przeszkody powinna trwać dłużej niż animacja wskakiwania na przeszkodę. Problem ten został rozwiązany za pomocą rozbicia sekwencji skoku na 3 oddzielne animacje – wybicie się, przebywanie w powietrzu oraz lądowanie. Ostatnia klatka wybicia jest jednocześnie pierwszą i ostatnią klatką przebywania w powietrzu oraz pierwszą klatką lądowania. Pozwoliło to na zapętlone odgrywanie animacji przebywania w powietrzu z płynnymi przejściami pomiędzy wybiciem a lądowaniem.


\chapter{Kolejny rozdział}

\begin{thebibliography}{9}

\bibitem{learning-unreal}
Joanna Lee, \textit{Learning Unreal Engine Game Development}, Packt Publishing, 2016

\bibitem{docs-ue4-features}
\textit{Engine Features}, \url{https://docs.unrealengine.com/latest/INT/Engine/index.html} (dostęp 30.12.2017)

\bibitem{docs-blueprints}
\textit{Blueprints Visual Scripting}, \url{https://docs.unrealengine.com/latest/INT/Engine/Blueprints/index.html} (dostęp 30.12.2017)

\bibitem{docs-gameplay-framework}
\textit{Gameplay Framework Quick Reference}, \url{https://docs.unrealengine.com/latest/INT/Gameplay/Framework/QuickReference/index.html} (dostęp 31.12.2017)

\bibitem{wiki-game-engine}
\textit{,,Game engine``, Wikipedia}, \url{https://en.wikipedia.org/wiki/Game_engine} {\mbox(dostęp 29.12.2017)}

\bibitem{unreal-wiki-replication}
\textit{Everything you ever wanted to know about replication (but were afraid to ask)}, \url{https://wiki.beyondunreal.com/Everything_you_ever_wanted_to_know_about_replication_\%28but_were_afraid_to_ask\%29#Function_call_replication_-_Sending_messages_between_server_and_client} (dostęp 30.12.2017)

\bibitem{nasdaq-video-games-industry}
Trevir Nath, \textit{Investing in Video Games: This Industry Pulls In More Revenue Than Movies, Music},
\url{http://www.nasdaq.com/article/investing-in-video-games-this-industry-pulls-in-more-revenue-than-movies-music-cm634585} {\mbox(dostęp 29.12.2017)}

\bibitem{the-human-race}
\textit{The Human Race – An Inside Look at the Technology Behind the Groundbreaking Real-Time Film from Epic Games, The Mill and Chevrolet}, \url{https://www.unrealengine.com/en-US/showcase/the-human-race-an-inside-look-at-the-technology-behind-the-groundbreaking-real-time-film-from-epic-games-the-mill-and-chevrolet} (dostęp 30.12.2017)

\bibitem{ikea-vr}
\textit{VIRTUAL REALITY - INTO THE MAGIC}, \url{http://www.ikea.com/ms/en_US/this-is-ikea/ikea-highlights/Virtual-reality/index.html} (dostęp 30.12.2017)

\bibitem{whats-rigging}
Justin Slick, \textit{What is Rigging? Preparing a 3D Model For Animation }, \url{https://www.lifewire.com/what-is-rigging-2095}  (dostęp 3.01.2018)

\bibitem{docs-playercontroller}
\textit{UE4 - Documentation - Player Controller}, \url{https://docs.unrealengine.com/latest/INT/Gameplay/Framework/Controller/PlayerController/}  (dostęp 3.01.2018)

\bibitem{docs-charactermovementcomponent}
\textit{UE4 - Documentation - Character Movement Component}, \url{https://docs.unrealengine.com/latest/INT/Gameplay/Networking/CharacterMovementComponent/index.html}  (dostęp 3.01.2018)

\bibitem{uewiki-charmovement}
\textit{UE4 Wiki - Authoritative Networked Character Movement}, \url{https://wiki.unrealengine.com/Authoritative_Networked_Character_Movement}  (dostęp 3.01.2018)


\end{thebibliography}


\beforelastpage

\end{document} 